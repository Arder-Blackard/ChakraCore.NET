<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>

<# int totalItems=7;
int startFrom=0;
#>
using ChakraCore.NET.API;
using System;
using System.Collections.Generic;
using static ChakraCore.NET.API.JavaScriptContext;
namespace ChakraCore.NET
{
public partial class JSValueConverter
{
    <#
    for (int i = startFrom; i <= totalItems; i++)
    {
      #>
        private JavaScriptValue toJSMethod<#=genCode(i,"T{1}")#> (ValueConvertContext context, Action<#=genCode(i,"T{1}")#> a)
        {
            JavaScriptNativeFunction f = (callee, isConstructCall, arguments, argumentCount, callbackData) =>
            {
                if (argumentCount != <#=i+1#>)
                {
                    throw new InvalidOperationException("call from javascript did not pass enough parameters");
                }
                //context.JSClass = arguments[0];//put the caller object to context
                <#=genCode(i,"T{1} para{1} = FromJSValue<T{1}>(context, arguments[{1}]);",false,Environment.NewLine,"{0}")#>

                //context.RuntimeContext.Leave();//leave the context. [1]user method does not require javascript context  [2]user may switch thread in the code.

                a(<#=genCode(i,"para{1}",false,",","{0}")#>);

                context.RuntimeContext.Enter();//restore context
                return context.RuntimeContext.JSValue_Undefined;
            };
            context.Handler.Hold(f);

            return context.RuntimeContext.With<JavaScriptValue>(()=>
                {
                    return JavaScriptValue.CreateFunction(f);
                }
            );
        }
        
        private JavaScriptValue toJSFunction<#=genCode(i,"T{1}",true)#> (ValueConvertContext context, Func<bool<#=genCode(i,",T{1}",false,"","{0}")#>,TResult> callback)
        {
            JavaScriptNativeFunction f = (callee, isConstructCall, arguments, argumentCount, callbackData) =>
            {
                if (argumentCount != <#=i+1#>)
                {
                    throw new InvalidOperationException("call from javascript did not pass enough parameters");
                }
                //context.JSClass = arguments[0];//put the caller object to context
                <#=genCode(i,"T{1} para{1} = FromJSValue<T{1}>(context, arguments[{1}]);",false,Environment.NewLine,"{0}")#>

                //context.RuntimeContext.Leave();//leave the context. [1]user method does not require javascript context  [2]user may switch thread in the code.

                TResult result=callback(isConstructCall<#=genCode(i,",para{1}",false,"","{0}")#>);

                context.RuntimeContext.Enter();//restore context
                return ToJSValue<TResult>(context,result);;
            };
            context.Handler.Hold(f);

            return context.RuntimeContext.With<JavaScriptValue>(()=>
            {
                return JavaScriptValue.CreateFunction(f);
            }
            );
        }

        private Action<#=genCode(i,"T{1}")#> fromJSMethod<#=genCode(i,"T{1}")#>(ValueConvertContext context,JavaScriptValue value)
        {
            Action<#=genCode(i,"T{1}")#> result = (<#=genCode(i,"T{1} para{1}",false,",","{0}")#>) =>
              {

                  <#=genCode(i,"JavaScriptValue p{1} = ToJSValue<T{1}>(context,para{1});",false,Environment.NewLine,"{0}")#>
                  

                  context.RuntimeContext.With(()=>
                  {
                      value.CallFunction(context.JSClass<#=genCode(i,",p{1}",false,"","{0}")#>);
                  });
              };
            return result;
        }

        private Func<bool,<#=genCode(i,"T{1}",true,",","{0}")#>> fromJSFunction<#=genCode(i,"T{1}",true)#>(ValueConvertContext context, JavaScriptValue value)
        {
            Func<bool,<#=genCode(i,"T{1}",true,",","{0}")#>> result = (bool isConstruct<#=genCode(i,",T{1} para{1}",false,"","{0}")#>) =>
            {
                <#=genCode(i,"JavaScriptValue p{1} = ToJSValue<T{1}>(context,para{1});",false,Environment.NewLine,"{0}")#>

                JavaScriptValue r=context.RuntimeContext.With<JavaScriptValue>(()=>
                {
                    if (isConstruct)
                    {
                        return value.ConstructObject(context.RuntimeContext.JSValue_Undefined);
                    }
                    else
                    {
                        return value.CallFunction(context.JSClass<#=genCode(i,",p{1}",false,"","{0}")#>);
                    }
                });
                return FromJSValue<TResult>(context,r);
            };
            return result;
        }


        private Func<<#=genCode(i,"T{1}",true,",","{0}")#>> fromJSCallbackFunction<#=genCode(i,"T{1}",true)#>(ValueConvertContext context, JavaScriptValue value)
        {
            Func<<#=genCode(i,"T{1}",true,",","{0}")#>> result = (<#=genCode(i,"T{1} para{1}",false,",","{0}")#>) =>
            {
                <#=genCode(i,"JavaScriptValue p{1} = ToJSValue<T{1}>(context,para{1});",false,Environment.NewLine,"{0}")#>

                JavaScriptValue r=context.RuntimeContext.With<JavaScriptValue>(()=>
                {
                    
                   return value.CallFunction(context.JSClass<#=genCode(i,",p{1}",false,"","{0}")#>);
                });
                return FromJSValue<TResult>(context,r);
            };
            return result;
        }

        private JavaScriptValue toJSCallbackFunction<#=genCode(i,"T{1}",true)#> (ValueConvertContext context, Func<<#=genCode(i,"T{1}",true,",","{0}")#>> callback)
        {
            JavaScriptNativeFunction f = (callee, isConstructCall, arguments, argumentCount, callbackData) =>
            {
                if (argumentCount != <#=i+1#>)
                {
                    throw new InvalidOperationException("call from javascript did not pass enough parameters");
                }
                //context.JSClass = arguments[0];//put the caller object to context
                <#=genCode(i,"T{1} para{1} = FromJSValue<T{1}>(context, arguments[{1}]);",false,Environment.NewLine,"{0}")#>

                //context.RuntimeContext.Leave();//leave the context. [1]user method does not require javascript context  [2]user may switch thread in the code.

                TResult result=callback(<#=genCode(i,"para{1}",false,",","{0}")#>);

                context.RuntimeContext.Enter();//restore context
                return ToJSValue<TResult>(context,result);;
            };
            context.Handler.Hold(f);

            return context.RuntimeContext.With<JavaScriptValue>(()=>
            {
                return JavaScriptValue.CreateFunction(f);
            }
            );
        }


        public void RegisterMethodConverter<#=genCode(i,"T{1}")#>()
        {
            RegisterConverter<Action<#=genCode(i,"T{1}")#>>(toJSMethod<#=genCode(i,"T{1}")#>, fromJSMethod<#=genCode(i,"T{1}")#>, false);
        }

        public void RegisterFunctionConverter<#=genCode(i,"T{1}",true)#>()
        {
            RegisterConverter<Func<bool<#=genCode(i,",T{1}",false,"","{0}")#>,TResult>>(toJSFunction<#=genCode(i,"T{1}",true)#>, fromJSFunction<#=genCode(i,"T{1}",true)#>,false);
        }

        public void RegisterCallbackFunctionConverter<#=genCode(i,"T{1}",true)#>()
        {
            RegisterConverter<Func<<#=genCode(i,"T{1}",true,",","{0}")#>>>(toJSCallbackFunction<#=genCode(i,"T{1}",true)#>, fromJSCallbackFunction<#=genCode(i,"T{1}",true)#>,false);
        }





        
      <#  
    }
    #>
    
}
}
<#+
private string genCode(int currentIndex,string pattern,bool genTResult=false,string joinWith=",",string outputPattern="<{0}>")
{
    StringBuilder sb=new StringBuilder();
    if (currentIndex==0 && !genTResult)
    {
        return "";
    }
    for (int i = 0; i < currentIndex; i++)
    {

        sb.AppendFormat(pattern,i,i+1); 

        sb.Append(joinWith);
    }
    if (genTResult)
    {
        sb.Append("TResult");
        sb.Append(joinWith);
    }
    if (sb.Length>1)
    {
        sb.Length-=joinWith.Length;
    }
    return string.Format(outputPattern,sb.ToString()) ;
}

#>